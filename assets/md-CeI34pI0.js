import{o as s,c as r,k as i,q as n,s as p,B as t,e}from"./modules/vue-BzsTFDC4.js";import{I as l}from"./slidev/default-BfqauN9D.js";import{u as c,f as d}from"./slidev/context-uQNT-pvr.js";import"./index-BT2WEJ27.js";import"./modules/shiki-B0vpeCRJ.js";const m=e("h2",null,"Federated Types",-1),h=e("div",{class:"dense"},[e("p",null," When it comes to TypeScript applications, the most common problem with using external libraries (which can be federated remote modules) is that not all of them provide TypeScript types with the original code. In the context of module federation, this problem is aggravated by the fact that Webpack only loads resources from the federated module at runtime, TypeScript, however, needs those during compilation. In this case you have the following options:"),e("p",null,"– @module-federation/native-federation-typescript,"),e("p",null,"– @module-federation/typescript,"),e("p",null,"– packaging your types for distribution via a package registry (e.g., npm),"),e("p",null,"– referencing types across monorepo (if possible)."),e("p",null," Note that TypeScript plugins are the easiest way to handle federated types. They fetch the types at compile-time and store within the project in order to make them available to tsc whenever it’s needed. ")],-1),u={__name:"slides.md__slidev_50",setup(f){const{$slidev:y,$nav:_,$clicksContext:o,$clicks:g,$page:v,$renderContext:b,$frontmatter:a}=c();return o.setup(),(k,w)=>(s(),r(l,n(p(t(d)(t(a),49))),{default:i(()=>[m,h]),_:1},16))}},C=u;export{C as default};
