import{b as s,o as r,w as p,g as e,ad as t,v as c,x as l,T as n}from"./modules/vue-WJU96poD.js";import{I as d}from"./slidev/default-CDHe6YmR.js";import{u as m,f as u}from"./slidev/context-D4L7Hmhe.js";import"./index-CmpTU64S.js";import"./modules/shiki-Ca4DXXqb.js";const w={__name:"slides.md__slidev_4",setup(h){const{$clicksContext:a,$frontmatter:i}=m();return a.setup(),(f,o)=>(r(),s(d,c(l(n(u)(n(i),3))),{default:p(()=>o[0]||(o[0]=[e("h2",null,"Other Approaches/1",-1),e("div",{class:"dense"},[e("p",null,[t("– "),e("strong",null,"Runtime Web Components"),t(": each micro frontend is mounted at a custom HTML element, and the container performs instantiation.")]),e("p",null,[t("– "),e("strong",null,"Runtime Javascript integration"),t(": somewhat similar to both the previous approach and module federation, this one includes each micro frontend onto the page using a "),e("code",null,"<script>"),t(" tag; the container application becomes an entry point, decides which micro frontend to be mounted, and calls the relevant function telling the micro frontend when and where to get rendered; each build file can be deployed independently.")]),e("p",null,[t("– "),e("strong",null,"iFrames"),t(": this approach is about rendering various micro frontends in separate iframes and composing those via a container application; the most obvious benefit of this approach is complete decoupling of the application components; however, this approach also has some substantial cons like composition complexity and high potential for performance issues.")])],-1)])),_:1,__:[0]},16))}};export{w as default};
