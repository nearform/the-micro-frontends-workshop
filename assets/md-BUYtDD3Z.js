import{o as s,c as i,k as r,q as c,s as p,B as o,e,aa as t}from"./modules/vue-BzsTFDC4.js";import{I as l}from"./slidev/default-BfqauN9D.js";import{u as d,f as m}from"./slidev/context-uQNT-pvr.js";import"./index-BT2WEJ27.js";import"./modules/shiki-B0vpeCRJ.js";const h=e("h2",null,"Other Approaches/1",-1),u=e("div",{class:"dense"},[e("p",null,[t("– "),e("strong",null,"Runtime Web Components"),t(": each micro frontend is mounted at a custom HTML element, and the container performs instantiation.")]),e("p",null,[t("– "),e("strong",null,"Runtime Javascript integration"),t(": somewhat similar to both the previous approach and module federation, this one includes each micro frontend onto the page using a "),e("code",null,"<script>"),t(" tag; the container application becomes an entry point, decides which micro frontend to be mounted, and calls the relevant function telling the micro frontend when and where to get rendered; each build file can be deployed independently.")]),e("p",null,[t("– "),e("strong",null,"iFrames"),t(": this approach is about rendering various micro frontends in separate iframes and composing those via a container application; the most obvious benefit of this approach is complete decoupling of the application components; however, this approach also has some substantial cons like composition complexity and high potential for performance issues.")])],-1),f={__name:"slides.md__slidev_4",setup(_){const{$slidev:g,$nav:v,$clicksContext:n,$clicks:b,$page:x,$renderContext:$,$frontmatter:a}=d();return n.setup(),(k,w)=>(s(),i(l,c(p(o(m)(o(a),3))),{default:r(()=>[h,u]),_:1},16))}},T=f;export{T as default};
